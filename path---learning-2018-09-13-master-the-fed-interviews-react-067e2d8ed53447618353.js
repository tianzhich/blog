webpackJsonp([0x6f6faca3b897],{284:function(n,a){n.exports={data:{markdownRemark:{html:'<h3 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>前言</h3>\n<p>秋招提前批已经基本结束了，即将进入金九银十，正式的号角已经打响。春招，以及秋招提前批一路过来，断断续续也面了一些公司，自己在笔记上也有总结，甚至自己进行过一些猜题。发现基本问到的问题八九不离十，但是有些知识，特别是偏工程的知识点，如果没遇到过，很难产生深刻的印象。结合自己之前的笔记，也想在正式进入9月之前，整理一个面试题集系列，加深理解</p>\n<p>这是这个系列的第五篇，关于React</p>\n<p>React作为一个火爆的前端框架，面试时被问到的基本原理题还是有点，现在我们越来越喜欢直接上手一个框架，而往往忽略一些基础，这篇文章也当做复习React基础知识了</p>\n<h3 id="一、react的生命周期"><a href="#%E4%B8%80%E3%80%81react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一、React的生命周期</h3>\n<p>React组件有三个生命周期，每种生命周期有一些函数可以调用，完成某些功能。其中以<strong>will</strong>作为前缀的方法在经历周期之前调用，以<strong>did</strong>作为前缀的方法在经历周期之后调用</p>\n<ol>\n<li>\n<p><strong>Mount</strong>，React组件初始化之后需要<strong>挂载</strong>到真实DOM，需要经历挂载这个生命周期，其中有几个重要的方法</p>\n<p><strong>constructor()</strong>，这个构造函数方法一般做两件事，首先是初始化组件状态；其次是组件中方法的作用域绑定。一般如果无需这两个操作，可以不定义constructor()方法，React.Component会默认实现</p>\n</li>\n</ol>\n<div class="gatsby-highlight" data-language="jsx">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">foo</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n      name<span class="token punctuation">:</span> <span class="token string">"foo"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// React.Component默认实现的constructor()</span>\n<span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n    color<span class="token punctuation">:</span> props<span class="token punctuation">.</span>initialColor\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>   <strong>render()</strong>，React使用该方法生成一颗Virtual DOM树</p>\n<p>   <strong>componentDidMount()</strong>，React组件被加载进入真实DOM后执行该函数，在该函数中可以发Ajax请求，绑定事件处理函数，添加计时器，操作真实DOM等等</p>\n<ol start="2">\n<li>\n<p><strong>Update</strong>，当React组件的state或者props发生变化时，需要经历更新这个生命周期，其中有几个重要的方法</p>\n<p><strong>static getDerivedStateFromProps(nextProps, prevState)</strong>，组件props改变，或者父组件引发的渲染会调用该方法，该方法根据组件props决定是否更新组件state，返回一个state对象用于更新state，或返回null表示无需更新。该方法也可以在<strong>挂载</strong>生命周期中使用</p>\n<p><strong>shouldComponentUpdate(nextProps, nextState)</strong>，React默认是props或state发生改变默认更新，如果我们需要自行决定是否更新，则需要自己实现这个方法。该方法返回false，则组件会停止更新，周期后面的方法不会调用\n<strong>componentDidUpdate(prevProps, prevState)</strong>，更新发生之后调用该方法，可以实现DOM操作</p>\n</li>\n<li>\n<p><strong>Unmount</strong>，当关闭一个网页，或者Virtual DOM树的根节点元素完全改变时，组件会经历<strong>卸载</strong>这个生命周期，其中只有一个比较重要的方法</p>\n<p><strong>componentWillUnmount()</strong>，该方法一般用来解除事件绑定，取消定时器等等，防止内存泄漏</p>\n</li>\n</ol>\n<h3 id="二、state-vs-props"><a href="#%E4%BA%8C%E3%80%81state-vs-props" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>二、State VS Props</h3>\n<p>先说说它们的相同点</p>\n<ul>\n<li>两者都是JavaScript对象</li>\n<li>两者的改变都会引起React组件的更新</li>\n</ul>\n<p>两者何时可以发生改变</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><em>props</em></th>\n<th><em>state</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能否从父组件获取初始值</td>\n<td>能</td>\n<td>能</td>\n</tr>\n<tr>\n<td>值能否被父组件改变</td>\n<td>能</td>\n<td>不能</td>\n</tr>\n<tr>\n<td>能否设置默认值</td>\n<td>能</td>\n<td>能</td>\n</tr>\n<tr>\n<td>能否在组件内发生改变</td>\n<td>不能</td>\n<td>能</td>\n</tr>\n<tr>\n<td>能否用来设置子组件的Props或State</td>\n<td>能</td>\n<td>能</td>\n</tr>\n<tr>\n<td>能否在子组件中被改变</td>\n<td>不能</td>\n<td>能</td>\n</tr>\n</tbody>\n</table>\n<p>总结来说</p>\n<ul>\n<li>state用于实现组件内部的逻辑，props定义了一个外部的接口</li>\n<li>props的初始化赋值在父组件中，state则在自身组件中</li>\n<li>父组件可以通过传值给子组件，作为子组件的props，子组件再使用props初始化state</li>\n<li>父组件也可以通过传递回调函数给子组件，从而在子组件中调用回调函数修改父组件state</li>\n</ul>\n<h4 id="参考"><a href="#%E5%8F%82%E8%80%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考</h4>\n<ol>\n<li><a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md">https://github.com/uberVU/react-guide/blob/master/props-vs-state.md</a></li>\n</ol>\n<h3 id="三、react-element-vs-react-component"><a href="#%E4%B8%89%E3%80%81react-element-vs-react-component" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>三、React Element VS React Component</h3>\n<ul>\n<li>React Element是构建React应用的基本单元，描述了我们在屏幕上看到的东西，具有不可变性(immutable)，也就是每次<code class="language-text">render()</code>方法返回的都是全新的React Element</li>\n<li>React Element只是一个对象，并不是真实的DOM节点，最终要由ReactDOM根据该对象生成真实的节点(<code class="language-text">ReactDOM.render()</code>)。通常我们不直接使用React Element，而是从React Component的render函数中返回</li>\n<li>React Component是一个抽象概念，是React中可重用的代码块，它可以返回React Element用于渲染真实DOM</li>\n<li>如果页面的一部分经常被重复使用，或者逻辑复杂，就可以考虑将其包装为Component</li>\n<li>Component是用户自定义的，Component也可以返回Component，而React Element是本来就存在的纯对象</li>\n</ul>\n<h3 id="四、类组件class-components-vs-函数组件functional-components"><a href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E7%BB%84%E4%BB%B6class-components-vs-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6functional-components" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>四、类组件(Class Components) VS 函数组件(Functional Components)</h3>\n<div class="gatsby-highlight" data-language="jsx">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token comment">// 函数组件</span>\n<span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 类组件</span>\n<span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>上面的代码中，两者对于React来说没有区别，因为函数返回的也是一个React Element</p>\n<p>但是函数组件功能单一，如果只需要返回一个React Element或者React Component的时候，使用功能组件即可</p>\n<p>如果组件有状态或者需要使用一些生命周期函数，则需要使用类组件</p>\n<h3 id="五、受控组件controled-component-vs-非受控组件uncontroled-component"><a href="#%E4%BA%94%E3%80%81%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controled-component-vs-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6uncontroled-component" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>五、受控组件(Controled Component) VS 非受控组件(Uncontroled Component)</h3>\n<ul>\n<li>对于受控组件，所有的组件数据托管在组件中，不为真实DOM所有</li>\n<li>对于非受控组件，通过<em>ref</em>绑定真实DOM元素，组件数据可以从真实DOM元素中获得</li>\n</ul>\n<p>关于受控组件和非受控组件的一个最好的例子就是如果需要获取<code class="language-text">&lt;input&gt;</code>元素的值，是否需要对其绑定<code class="language-text">onChange</code>事件</p>\n<ul>\n<li>如果不绑定事件，则直接从元素中获取value，需要使用<em>ref</em>绑定真实DOM，之后便可以直接访问<code class="language-text">value</code>，此时作为非受控组件</li>\n<li>如果绑定<code class="language-text">onChange</code>事件，每一次事件调用时便可以通过<code class="language-text">setState()</code>设置组件的state，值可以通过<code class="language-text">onChange</code>方法的默认参数：事件对象<code class="language-text">e.target.value</code>中获得，此时为受控组件</li>\n</ul>\n<h3 id="六、显示组件presentational-component-vs-容器组件container-component"><a href="#%E5%85%AD%E3%80%81%E6%98%BE%E7%A4%BA%E7%BB%84%E4%BB%B6presentational-component-vs-%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6container-component" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>六、显示组件(Presentational Component) VS 容器组件(Container Component)</h3>\n<p>关于这两种组件，还有哑组件(Dumb Coponent)和聪明组件(Smart Component)的说法</p>\n<p>顾名思义，显示组件做的工作就是只展示页面元素，而容器组件要实现的就是页面的业务逻辑</p>\n<p>两者有下面的区别</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>显示组件</th>\n<th>容器组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目的</td>\n<td>展示页面</td>\n<td>实现页面交互逻辑</td>\n</tr>\n<tr>\n<td>数据来源</td>\n<td>自身props</td>\n<td>与其他组件通信得到或者发出请求得到</td>\n</tr>\n<tr>\n<td>响应交互操作</td>\n<td>使用容器组件提供的回调函数</td>\n<td>触发真正的操作</td>\n</tr>\n</tbody>\n</table>\n<p>关于这两者的概念，诠释得最清晰的是Redux，Redux的<code class="language-text">connect()</code>方法可以将一个显示组件包装成为一个容器组件，并且将容器组件获得的数据通过props传给显示组件进行显示，同时，将修改状态的回调方法也通过props传给显示组件，让其可以调用回调方法完成交互</p>\n<p>看下面一幅图就明白了</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/blog/static/redux-flow-by-buckyroberts-723e2936f369a4e3e82d645a4a0bd450-6ebfa.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 850px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 225.22522522522524%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,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\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="redux flow by buckyroberts"\n        title=""\n        src="/blog/static/redux-flow-by-buckyroberts-723e2936f369a4e3e82d645a4a0bd450-8d63b.png"\n        srcset="/blog/static/redux-flow-by-buckyroberts-723e2936f369a4e3e82d645a4a0bd450-16ce1.png 213w,\n/blog/static/redux-flow-by-buckyroberts-723e2936f369a4e3e82d645a4a0bd450-898e7.png 425w,\n/blog/static/redux-flow-by-buckyroberts-723e2936f369a4e3e82d645a4a0bd450-8d63b.png 850w,\n/blog/static/redux-flow-by-buckyroberts-723e2936f369a4e3e82d645a4a0bd450-6ebfa.png 888w"\n        sizes="(max-width: 850px) 100vw, 850px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    \n<span>Redux Flow by <a href="https://github.com/buckyroberts">buckyroberts</a></span></p>\n<h3 id="七、react高阶组件hoc"><a href="#%E4%B8%83%E3%80%81react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6hoc" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>七、React高阶组件(HOC)</h3>\n<p>React High Order Component (HOC) 是React用来复用组件逻辑的一种技术。本质上来说，高阶组件就是一个函数，函数接收一个组件作为参数，在此基础上增加一些新的功能，最后返回一个新的组件，例如</p>\n<div class="gatsby-highlight" data-language="jsx">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">logProps</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>\n    <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Current props: \'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Next props: \'</span><span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>WrappedComponent</span> <span class="token spread"><span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token attr-value">this</span><span class="token punctuation">.</span><span class="token attr-value">props</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>高阶组件在React第三方库中出现得比较多，其中最为常见的是React-Redux中的<code class="language-text">connect()</code>，该方法的返回值就是一个高阶组件，下面是该函数的模型</p>\n<div class="gatsby-highlight" data-language="jsx">\n      <pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">connect</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// we return a Wrapper component:</span>\n    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>\n      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">(</span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>WrappedComponent</span>\n            <span class="token spread"><span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token attr-value">this</span><span class="token punctuation">.</span><span class="token attr-value">props</span><span class="token punctuation">}</span></span>\n          <span class="token punctuation">/></span></span>\n        <span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>还有一点需要注意，HOC看起来和前面提到的<em>Container Component</em>非常相似，下面是React官网给出的解释</p>\n<blockquote>\n<p>You may have noticed similarities between HOCs and a pattern called <strong>container components</strong>. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</p>\n</blockquote>\n<p>其实大致意思就是，HOC实现了Container Component，它的返回值就是这个，只不过它作为一个函数，可以传递额外的参数来增强Container Component的功能</p>\n<p>使用HOC有如下几个好处</p>\n<ul>\n<li>HOC可以使用同一个Component，返回不同的Container Component，可以复用组件，减少代码</li>\n<li>HOC可以传递不同的数据源作为参数，方便我们使用不同的数据源</li>\n</ul>',frontmatter:{title:"面试的那些题-React篇",date:"September 13, 2018",excerpt:"最近想复习总结下面试中遇到的所有面试题，以及自己觉得可能出现的面试题，又或者是我觉得不错的需要掌握的知识。这是Master the FED Interviews系列的第五篇：关于React",contents:[{text:"前言",subContents:null},{text:"一、react的生命周期",subContents:null},{text:"二、state-vs-props",subContents:null},{text:"三、react-element-vs-react-component",subContents:null},{text:"四、类组件class-components-vs-函数组件functional-components",subContents:null},{text:"五、受控组件controled-component-vs-非受控组件uncontroled-component",subContents:null},{text:"六、显示组件presentational-component-vs-容器组件container-component",subContents:null},{text:"七、react高阶组件hoc",subContents:null}]}}},pathContext:{slug:"/learning/2018/09/13/Master-the-FED-Interviews-React/"}}}});
//# sourceMappingURL=path---learning-2018-09-13-master-the-fed-interviews-react-067e2d8ed53447618353.js.map